숫자는 float 실수형. 5 === 5.0

함수의 매개변수에는 type을 지정해줘야함
그러나 let이나 const로 정의된 변수나 상수는 type을 지정하지 않아도 typescript는 이 변수나 상수의 type을 알 수 있음. 해당 변수, 상수에 할당된 값의 type을 그대로 가지고 가기 때문.-> 타입추론 이라는 기능. 물론 변수나 상수에 `: type`을 명시해서 함수의 매개변수에 type을 지정해주는 것 처럼 할 수도 있긴하다. 변수나 상수에 초깃값을 할당하지 않을 때에는 이런식으로 type을 지정해주어야 함. 그러나 초깃값이 있다면 typescript는 해당 초깃값의 type을 해당 변수,상수의 type으로 잘 인식하기 때문에 중복해서 또 type을 지정해줄 필요는 없음.


ts는 변수에 객체를 할당하면 js객체와 비슷하지만 다른 '객체 타입' 이라는 것을 작성함. 기존 js객체는 key-value쌍을 가지고 있지만 객체 타입은 key-type쌍을 가지고 있으며 다음 쌍으로 넘어갈때 콤마가아니라 세미콜론을 쓴다. 이런 일반적인 객체 타입은 `: object`로 type을 지정해 줄 수 있음. 그런데 이렇게 : object로 type을 지정해주면 ts는 이 객체의 내부에 접근을 못함.(person.name 에서 name을 찾지 못해 컴파일 오류가 난다.) 따라서 : {키1: type1; 키2: type2;} 형태로 지정해 주어야 한다. 하지만 위에서 말했듯이 ts는 타입 추론이라는 기능을 내장하고 있기 때문에, 변수에 명시적인 객체를 할당하면 이런 작업을 할 필요없이 ts는 자동으로 할당된 초깃값에 알맞은 객체 타입을 생성한다. 직접 객체 타입을 지정하는 경우는 변수에 명시적인 객체를 할당하지 않을 때, 해주는 것이 바람직하다.

배열의 경우에도 변수에 배열을 할당해주면 타입 추론이 작동하여 배열 내부에 어떤 타입이 있는지 ts가 자동으로 추적한다. 만약 변수에 배열을 할당하지않고 타입만 할당하고 싶다면 : string[] 과 같이 배열을 나타내는 대괄호 앞에 배열에 들어가는 요소의 타입을 명시해주면된다. for of문을 사용하면 ts의 타입추론 덕분에 for문 내부에서 타입을 지정해주지 않더라도 ts가 알아서 위에 있는 객체와 배열의 타입을 추적해준다. 그래서 문자열 hobby에 map 메서드를 사용하려하면 에러를 내보낸다.

튜플 타입 - js에는 없는 타입이다. 배열인데 길이와 타입이 고정된 타입을 튜플이라고 한다. 배열의 몇번째 요소에 어떤 타입을 갖게 하고 싶고, 배열의 길이를 한정시키고 싶은데, 배열 타입을 사용하면 ts는 이 같은 조건들을 인식하지 못한다. 이때 필요한 것이 튜플 타입이다. 튜플 타입은 `: [type, type]` 과 같이 명시해줄 수 있다. 다만 push에 대해서는 튜플에서 허용되기 때문에 타입스크립트가 에러를 걸러내줄 수 없다. 하지만 튜플의 길이와 내부 요소의 타입에 대해선 에러를 잘 잡아낸다.

enum타입 - enum{NEW, OLD} 열거형 타입 - 숫자에 인간이 읽을 수 있는 라벨이 붙어있는 타입이다. 즉 enum.NEW는 코드상으로는 NEW이지만 컴퓨터는 숫자 0으로 인식한다. 기본적으로 첫 번째 요소부터 0이 할당되지만, NEW = 5 와 같이 첫 번째 요소에 할당하고 싶은 숫자를 넣어주면 그 뒤로 6 7 8 오름차순으로 숫자들이 할당된다. 필요하다면 각각의 요소에 원하는 숫자나 텍스트를 할당해도 된다.

any타입 - 타입스크립트가 어떤 타입도 상관하지 않게 해주는 타입. 하지만 어떤 값도 저장하지 않아서 타입스크립트 컴파일러가 검사할 부분이 없어지기 때문에, 타입스크립트의 장점을 살리지 못해 잘 사용하지 않는다.

union타입 - 변수에 여러 타입을 명시하고 싶을 때 사용한다. `: number | string`
그런데 이렇게 써놓고 보면 이런 에러가 발생한다.
'+' 연산자를 'string | number' 및 'string | number' 형식에 적용할 수 없습니다.
하지만 우리가 알고 있기로, js에서 더하기 연산자는 숫자와 문자열 모두 사용할 수 있기때문에 문제가 없어야한다. 이런 오류가 발생하는 이유는 타입스크립트가 유니언 타입만 이해할 뿐, 유니언 타입 내에 무엇이 있는지는 분석하지 못하기 때문이다. 이럴 때에는 if문을 통해 런타임 타입 검사를 추가해주면 된다.

리터럴타입 - 정확한 값을 가지는 타입 const number2 = 2.8;
유니온타입과 함께 사용함으로써 개발자가 리터럴타입에 필요한 값을 모두 기억하지 않아도 되도록 하고, 오타가 발생했을 때 ts가 이를 감지하여 오류를 내보낼 수 있게 해준다.

타입 알리어스 - 사용자 정의 타입. type Combinable(사용자정의이름) = number | string;

함수의 return타입
TS는 함수의 return 타입을 지정하지 않아도 알아서 추론한다. 만약 명시하고 싶다면 `function (): type`으로 지정해줄 수 있다. 이때에는 TS가 추론하는 return타입과 명시한 return타입이 일치해야 오류가 발생하지 않는다. 그러므로 변수와 마찬가지로 TS가 return타입을 추론 가능한 상황이라면, 별도로 지정하는 것은 피하는 것이 좋다. 
만약 함수가 어떠한 리턴도 갖고 있지 않다면 TS는 그 함수의 리턴타입으로 void타입을 추론한다. JS에서는 함수가 리턴을 갖고있지 않을 때, undefined라는 '값'을 리턴한다. 그런데 TS에서는 undefined도 타입이다. 만약 함수의 리턴타입으로 undefined를 설정하고 싶다면, 그 함수는 값을 반환하지않는 return이 있어야한다. 
정리하면 값을 반환하지 않는 함수는 기본적으로 void를 리턴타입으로 사용한다. TS는 이런 함수를 알아서 void 리턴타입을 갖는다고 추론한다. 만약 리턴타입을 undefined로 지정하고싶다면, 값을 반환하지 않는 return문을 꼭 작성해야 오류를 내지않는다.

함수 타입
함수 그 자체도 타입으로 지정할 수 있다. 기본적으로 : Function을 통해 지정할 수 있지만, 이렇게 지정하면 TS는 그 변수에 할당된 함수가 어떤 함수인지 알지 못한다. 만약 할당된 함수의 매개변수와 리턴값까지 지정해주고 싶다면 : (매개변수1: type, 매개변수2: type) => type; 과 같이 할 수 있다.

콜백함수에도 이렇게 지정할 수 있음. 그런데 콜백함수의 리턴타입을 void로 지정하고 리턴값을 주더라도 TS는 오류를 내지 않음. 이것은 버그가 아니라 콜백함수가 리턴타입으로 아무 작업도 수행하지 않을 것을 나타내는 것임. 그러니까 콜백의 리턴타입을 void로 지정하는 것은 콜백함수가 리턴을 갖지 않는다는 것을 의미하는 것이아니라, 단지 리턴값을 사용되지 않도록 요구하는 것임.

unknown타입
any 타입과 유사하게 unknown타입으로 명시된 변수에는 어떤 타입이든 할당할 수 있다. 하지만 any타입은 타입 검사를 하지 않는 반면, unknown 타입으로 명시된 변수는 TS가 타입검사를 엄격하게 진행한다. 그러므로 string타입으로 명시된 변수에 unknown타입으로 명시된 변수를 할당하게되면 오류가 발생하고, 이를 피하기 위해서는 조건문을 통한 타입검사가 필요하다. 

never타입
never타입은 void타입과 유사하게 리턴값이 없는 함수의 리턴타입이 될 수 있다. 하지만 void타입과는 다르게, never타입이 리턴되는 함수를 console로 찍어보면 undefined가 반환되지 않는다. 이는 never타입을 반환하는 함수가 스크립트와 충돌하면서 스크립트가 취소되기 때문이다. 이렇게 never를 리턴타입으로하는 함수를 IDE에서 살펴보면 void를 리턴한다고 되어있는데, 이는 never가 void보다 최신 타입이기 때문에 아직 IDE에 반영이 되지 않았기 때문이다.
